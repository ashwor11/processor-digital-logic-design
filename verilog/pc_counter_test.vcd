$date
	Sat Jan 06 03:24:39 2024
$end
$version
	ModelSim Version 10.5b
$end
$timescale
	1ps
$end

$scope module PC_Counter_Testbench $end
$var reg 11 ! jumpAddress [10:0] $end
$var reg 1 " nextInstr $end
$var reg 1 # jump $end
$var reg 1 $ cmpJump $end
$var reg 1 % clk $end
$var reg 1 & reset $end
$var reg 1 ' enable $end
$var wire 1 ( pc [10] $end
$var wire 1 ) pc [9] $end
$var wire 1 * pc [8] $end
$var wire 1 + pc [7] $end
$var wire 1 , pc [6] $end
$var wire 1 - pc [5] $end
$var wire 1 . pc [4] $end
$var wire 1 / pc [3] $end
$var wire 1 0 pc [2] $end
$var wire 1 1 pc [1] $end
$var wire 1 2 pc [0] $end

$scope module uut $end
$var wire 1 3 jumpAddress [10] $end
$var wire 1 4 jumpAddress [9] $end
$var wire 1 5 jumpAddress [8] $end
$var wire 1 6 jumpAddress [7] $end
$var wire 1 7 jumpAddress [6] $end
$var wire 1 8 jumpAddress [5] $end
$var wire 1 9 jumpAddress [4] $end
$var wire 1 : jumpAddress [3] $end
$var wire 1 ; jumpAddress [2] $end
$var wire 1 < jumpAddress [1] $end
$var wire 1 = jumpAddress [0] $end
$var wire 1 > nextInstr $end
$var wire 1 ? jump $end
$var wire 1 @ cmpJump $end
$var wire 1 A clk $end
$var wire 1 B reset $end
$var wire 1 C enable $end
$var reg 11 D pc [10:0] $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
bx !
0"
0#
0$
0%
1&
1'
b0 D
02
01
00
0/
0.
0-
0,
0+
0*
0)
0(
1C
1B
0A
0@
0?
0>
x=
x<
x;
x:
x9
x8
x7
x6
x5
x4
x3
$end
#5
1"
0&
1%
1>
0B
1A
b1 D
12
#10
0"
1#
b11111111011 !
0%
1%
0>
1?
1=
1<
0;
1:
19
18
17
16
15
14
13
#15
0%
0A
#20
1%
1A
b11111111100 D
02
10
1/
1.
1-
1,
1+
1*
1)
1(
#25
0%
0A
#30
1%
1A
b11111110111 D
12
11
0/
#35
0%
0A
#40
1%
1A
b11111110010 D
02
00
